<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>无尽光芒</title>
    <link>https://fredia.github.io/</link>
    <description>Recent content on 无尽光芒</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 09 Jul 2019 10:53:00 +0800</lastBuildDate>
    
	<atom:link href="https://fredia.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>推荐系统理论学习</title>
      <link>https://fredia.github.io/posts/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Tue, 09 Jul 2019 10:53:00 +0800</pubDate>
      
      <guid>https://fredia.github.io/posts/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/</guid>
      <description></description>
    </item>
    
    <item>
      <title>partition的几种写法</title>
      <link>https://fredia.github.io/posts/%E5%BF%AB%E6%8E%92%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95/</link>
      <pubDate>Mon, 08 Jul 2019 11:40:00 +0800</pubDate>
      
      <guid>https://fredia.github.io/posts/%E5%BF%AB%E6%8E%92%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95/</guid>
      <description>partition一般用于快速排序中，也可用于求无序数组的第k大(中位数)等问题。partition的思想是根据一个哨兵(pivot)将数组分为大于(等于)或小于(等于)pivotde的两部分。 在pa</description>
    </item>
    
    <item>
      <title>孤儿，僵尸，守护进程</title>
      <link>https://fredia.github.io/posts/%E5%AD%A4%E5%84%BF%E5%83%B5%E5%B0%B8%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Sat, 15 Jun 2019 10:40:00 +0800</pubDate>
      
      <guid>https://fredia.github.io/posts/%E5%AD%A4%E5%84%BF%E5%83%B5%E5%B0%B8%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</guid>
      <description>在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个进程完成它的工作终止之</description>
    </item>
    
    <item>
      <title>《Redis的设计与实现》读书笔记(3)</title>
      <link>https://fredia.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_redis%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B03/</link>
      <pubDate>Fri, 07 Jun 2019 15:40:00 +0800</pubDate>
      
      <guid>https://fredia.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_redis%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B03/</guid>
      <description>三.多机数据库的实现 1.复制 在Redis中，用户可以通过slaveof命令或者slaveof选项实现，让一个服务器去复制（replicate）另一个服务器。 1.1旧版复制功能的实现（2.8版前） Red</description>
    </item>
    
    <item>
      <title>《Redis的设计与实现》读书笔记(2)</title>
      <link>https://fredia.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_redis%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B02/</link>
      <pubDate>Mon, 03 Jun 2019 10:40:00 +0800</pubDate>
      
      <guid>https://fredia.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_redis%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B02/</guid>
      <description>二、单机数据库的实现 1.数据库 1.1 服务器中的数据库 struct redisServer { /* General */ // 配置文件的绝对路径 char *configfile; /* Absolute config file path, or NULL */ // serverCron() 每秒调用的次数 int hz; /* serverCron() calls frequency in hertz */ // 数据库 redisDb *db; ... int dbnum; /* Total number of configured DBs 默认值为16*/ }; 1.2 切换数据库 切换</description>
    </item>
    
    <item>
      <title>synchronized实现原理</title>
      <link>https://fredia.github.io/posts/synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sat, 01 Jun 2019 00:08:00 +0800</pubDate>
      
      <guid>https://fredia.github.io/posts/synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>一、synchronized的基本使用 &amp;emsp;synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。Synchronized的作用主要有三个： 确保线程互斥的访问</description>
    </item>
    
    <item>
      <title>《Redis的设计与实现》读书笔记(1)</title>
      <link>https://fredia.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_redis%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B01/</link>
      <pubDate>Wed, 29 May 2019 23:40:00 +0800</pubDate>
      
      <guid>https://fredia.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_redis%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B01/</guid>
      <description>&lt;h1 id=&#34;一-数据结构与对象&#34;&gt;一、数据结构与对象&lt;/h1&gt;

&lt;h2 id=&#34;1-sds-简单字符串&#34;&gt;1.SDS（简单字符串）&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>Java中的String</title>
      <link>https://fredia.github.io/posts/java%E4%B8%AD%E7%9A%84string/</link>
      <pubDate>Tue, 21 May 2019 23:40:00 +0800</pubDate>
      
      <guid>https://fredia.github.io/posts/java%E4%B8%AD%E7%9A%84string/</guid>
      <description>Java中的String 概述（1.8 和1.9 对比） String被声明为final，因此它不可继承 在1.8中，String内部使用char数组存储 public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence { /** The value is used for character storage. */ private final char value[]; } 1.9 中，St</description>
    </item>
    
    <item>
      <title>字符串hash</title>
      <link>https://fredia.github.io/posts/string_hash/</link>
      <pubDate>Tue, 21 May 2019 13:12:00 +0800</pubDate>
      
      <guid>https://fredia.github.io/posts/string_hash/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;转载自：&lt;a href=&#34;https://www.zybuluo.com/xzyxzy/note/1173636&#34;&gt;https://www.zybuluo.com/xzyxzy/note/1173636&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;哈希表常用于比较两个字符串是否相同（可以把状态看作字符串，从而比较状态是否相同）&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://fredia.github.io/about/</link>
      <pubDate>Tue, 21 May 2019 13:06:28 +0800</pubDate>
      
      <guid>https://fredia.github.io/about/</guid>
      <description>nickname：fredia email：frediaray@163.com</description>
    </item>
    
  </channel>
</rss>